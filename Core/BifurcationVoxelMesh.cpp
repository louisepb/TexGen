#include "PrecompiledHeaders.h"
#include "BifurcationVoxelMesh.h"
#include "TexGen.h"
#include "PeriodicBoundaries.h"
#include <iterator>
#include <tuple>
//#define SHINY_PROFILER TRUE


using namespace TexGen;

CBifurcationVoxelMesh::CBifurcationVoxelMesh(string Type) : CVoxelMesh(Type)
{
}

CBifurcationVoxelMesh::~CBifurcationVoxelMesh(void)
{
	//delete m_PeriodicBoundaries;
}

void CBifurcationVoxelMesh::InitialiseBifurcationVoxelMesh(double a, double b, double c, double firstweb, double secondweb, double flangelength)
{
	m_a=a;
	m_b=b;
	m_c=c;
	m_firstweb=firstweb;
	m_secondweb=secondweb;
	m_flangelength=flangelength;
	return;
}



double CBifurcationVoxelMesh::geta()
{
	return m_a;
}

double CBifurcationVoxelMesh::getb()
{
	return m_b;
}

double CBifurcationVoxelMesh::getc()
{
	return m_c;
}

double CBifurcationVoxelMesh::getsecondweb()
{
	return m_secondweb;
}

double CBifurcationVoxelMesh::getflangelength()
{
	return m_flangelength;
}

void CBifurcationVoxelMesh::SaveVoxelMesh(CTextile &Textile, string OutputFilename, int XVoxNum, int YVoxNum, int ZVoxNum, bool bOutputMatrix, bool bOutputYarns, bool surfaceOutput, int iBoundaryConditions, int iElementType)
{
	//PROFILE_SHARED_DEFINE(ProfileTest)
	//PROFILE_FUNC()

	const CDomain* pDomain = Textile.GetDomain();
	if (!pDomain)
	{
		TGERROR("Unable to create ABAQUS input file: No domain specified");
		return;
	}
	//PROFILE_SHARED_BEGIN(ProfileTest);
	m_XVoxels = XVoxNum;
	m_YVoxels = YVoxNum;
	m_ZVoxels = ZVoxNum;
	TGLOG("Calculating voxel sizes");
	if (!CalculateVoxelSizes(Textile))
	{
		TGERROR("Unable to create ABAQUS input file: Error calculating voxel sizes");
		return;
	}
	TGLOG("Replacing spaces in filename with underscore for ABAQUS compatibility");
	OutputFilename = ReplaceFilenameSpaces(OutputFilename);
	//GetYarnGridIntersections(Textile);
	CTimer timer;
	timer.start("Timing SaveToAbaqus");
	SaveToAbaqus(OutputFilename, Textile, bOutputMatrix, bOutputYarns, surfaceOutput, iBoundaryConditions, iElementType);
	timer.check("End of SaveToAbaqus");
	timer.stop();

	// PROFILE_END();
	// PROFILER_UPDATE();
	// PROFILER_OUTPUT("ProfileOutput.txt");
	//SaveToSCIRun( OutputFilename, Textile );
}

bool CBifurcationVoxelMesh::CalculateVoxelSizes(CTextile &Textile)
{
	XYZ DomSize;

	m_DomainAABB = Textile.GetDomain()->GetMesh().GetAABB();
	DomSize = m_DomainAABB.second - m_DomainAABB.first;

	m_VoxSize[0] = DomSize.x / m_XVoxels;
	m_VoxSize[1] = DomSize.y / m_YVoxels;
	m_VoxSize[2] = DomSize.z / m_ZVoxels;
	return true;
}


void CBifurcationVoxelMesh::SaveToAbaqus(string Filename, CTextile &Textile, bool bOutputMatrix, bool bOutputYarn, bool surfaceOutput, int iBoundaryConditions, int iElementType)
{
	//PROFILE_FUNC();
	AddExtensionIfMissing(Filename, ".inp");

	ofstream Output(Filename.c_str());

	if (!Output)
	{
		TGERROR("Unable to output voxel mesh to ABAQUS file format, could not open file: " << Filename);
		return;
	}

	TGLOG("Saving voxel mesh data to " << Filename);

	

	Output << "*Heading" << endl;
	Output << "File generated by TexGen v" << TEXGEN.GetVersion() << endl;

	Output << "************" << endl;
	Output << "*** MESH ***" << endl;
	Output << "************" << endl;
	Output << "*Node" << endl;
	//PROFILE_BEGIN(OutputNodes);
	OutputNodes(Output, Textile, surfaceOutput);

	

	//PROFILE_END();
	TGLOG("Outputting hex elements");
	//Output the voxel HEX elements
	int iNumHexElements = 0;
	if (!iElementType)
	{
		Output << "*Element, Type=C3D8R" << endl;
	}
	else
	{
		Output << "*Element, Type=C3D8" << endl;
	}
	//PROFILE_BEGIN(OutputHexElements);
	iNumHexElements = OutputHexElements(Output, Textile, bOutputMatrix, bOutputYarn);
	


	//PROFILE_END();
	bool bMatrixOnly = false;
	if (bOutputMatrix && !bOutputYarn)
		bMatrixOnly = true;

	if (bOutputYarn)
	{
		TGLOG("Outputting orientations & element sets");
		//PROFILE_BEGIN(OutputOrientations);
		OutputOrientationsAndElementSets(Filename, Output);
		//PROFILE_END();
	}
	else if (bMatrixOnly)
	{
		OutputMatrixElementSet(Filename, Output, iNumHexElements, bMatrixOnly);
	}
	//PROFILE_BEGIN(OutputNodeSets);
	OutputAllNodesSet(Filename, Output);

	//m_Materials.SetUpMaterials( Textile );

	//CreateMaterials( Output, Textile.GetNumYarns(), bMatrixOnly);
	//PROFILE_END();

	CreateBifurcatedMaterials(Output, Filename, Textile, false);
	
	/*if (iBoundaryConditions != NO_BOUNDARY_CONDITIONS)
	{
		//PROFILE_BEGIN(OutputPBCs);
		OutputPeriodicBoundaries(Output, Textile, iBoundaryConditions, bMatrixOnly);
		//PROFILE_END();
	}*/
	TGLOG("Finished saving to Abaqus");
}


void CBifurcationVoxelMesh::OutputNodes(ostream &Output, CTextile &Textile, bool surfaceOutput, bool bAbaqus)
{
	int x, y, z;
	int iNodeIndex = 1;
	XYZ Point;
	double tol=0.0001; //needs to be smaller than a reasonable voxel size

	if (!bAbaqus)  // if outputting in SCIRun format need to output number of voxels
		Output << (m_XVoxels + 1)*(m_YVoxels + 1)*(m_ZVoxels + 1) << endl;
	int counter = 0;
	for (z = 0; z <= m_ZVoxels; ++z)
	{
		for (y = 0; y <= m_YVoxels; ++y)
		{
			for (x = 0; x <= m_XVoxels; ++x)
			{
				//define Point
				Point.x = m_DomainAABB.first.x + m_VoxSize[0] * x;
				Point.y = m_DomainAABB.first.y + m_VoxSize[1] * y;
				Point.z = m_DomainAABB.first.z + m_VoxSize[2] * z;

				//output corners of elements
				if (bAbaqus)
					Output << iNodeIndex << ", ";																																																																																													
				Output << Point << endl;

				//If Point not the end point, calculate centrepoint of element
				//Node index needs to be in order
				
				if (x < m_XVoxels && y < m_YVoxels && z < m_ZVoxels+1) //make sure you know what you want here
				{
					
					//If node outside the bounded volume as defined by the following if statements
					// add to the outsidepoints vector
					if (Point.z >=m_secondweb-tol && Point.z <m_secondweb+tol && Point.y < m_b-tol)
					{
						Output << "**Point is in the domain but don't write the centre point" << endl;
					}

					else if (Point.z >=m_a-tol && Point.y >=m_b-tol)
					{
						Output << "**Point is in the domain but don't write the centre point" << endl;
					}

					else if (Point.z < m_firstweb-tol && Point.y <= m_a+tol && Point.y >= m_b-tol)
					{
						
					}

					else if (Point.z >= m_firstweb-tol && Point.z <m_secondweb-tol && Point.y <= m_a+tol && Point.y >= m_c-tol)
					{

					} 


					else if (Point.z >= m_secondweb-tol && Point.z < m_a-tol && Point.y <= m_a+tol && Point.y >= m_b-tol)
					{
						//do nothing
					}

					

					else
					{
						OutsidePoints.insert(OutsidePoints.end(), iNodeIndex);
					}
				
				}

				++iNodeIndex;
			} //x

				

		} //y

	
	}//z

}


bool CBifurcationVoxelMesh::IsSubset(vector<int> A, vector<int> B)
{
	//this function checks if some elements in A are in B
	vector<int> Count;
	for (vector<int>::iterator it = A.begin(); it != A.end(); ++it)
	{
		if (find(B.begin(), B.end(), *it) != B.end())
		{
			Count.push_back(*it);
		}

	}

	if (Count.size() != 0)
		return true;
	else
		return false;
}

int CBifurcationVoxelMesh::OutputHexElements(ostream &Output, CTextile &Textile, bool bOutputMatrix, bool bOutputYarn, bool bAbaqus)
{
	int numx = m_XVoxels + 1;
	int numy = m_YVoxels + 1;
	int x, y, z;
	vector<XYZ> CentrePoints;
	vector<POINT_INFO> RowInfo;
	vector<POINT_INFO>::iterator itElementInfo = m_ElementsInfo.begin();
	int iElementNumber = 1;

	vector<POINT_INFO> NewElementInfo;

	if (!bAbaqus)
		Output << m_XVoxels*m_YVoxels*m_ZVoxels << endl;
	
	int nodeindextemp=0;
	for (z = 0; z < m_ZVoxels; ++z)
	{
		for (y = 0; y < m_YVoxels; ++y)
		{
			for (x = 0; x < m_XVoxels; ++x)
			{
					
					if (bAbaqus)
					{	
						//Output << "vars" << x << "," << y << "," << z << endl;
						XYZ Point;
						Point.x = m_DomainAABB.first.x + m_VoxSize[0] * x;
						Point.y = m_DomainAABB.first.y + m_VoxSize[1] * y;
						Point.z = m_DomainAABB.first.z + m_VoxSize[2] * z;

						vector<int> CornerNodes;
						int f = (x + 1) + y*numx + z*numx*numy + 1;
						int g = (x + 1) + (y + 1)*numx + z*numx*numy + 1;
						int h = x + (y + 1)*numx + z*numx*numy + 1;
						int i = x + y*numx + z*numx*numy + 1;
						int j = (x + 1) + y*numx + (z + 1)*numx*numy + 1;
						int k = (x + 1) + (y + 1)*numx + (z + 1)*numx*numy + 1;
						int l = x + (y + 1)*numx + (z + 1)*numx*numy + 1;
						int m = x + y*numx + (z + 1)*numx*numy + 1;
						CornerNodes.push_back(f);
						CornerNodes.push_back(g);
						CornerNodes.push_back(h);
						CornerNodes.push_back(i);
						CornerNodes.push_back(j);
						CornerNodes.push_back(k);
						CornerNodes.push_back(l);
						CornerNodes.push_back(m);

						if (!IsSubset(CornerNodes, OutsidePoints))
						{
							Output << iElementNumber << ", ";
							Output << f << ", " << g << ", ";
							Output << h << ", " << i << ", ";
							Output << j << ", " << k << ", ";
							Output << l << ", " << m << endl;
							++iElementNumber;
							
							//find centrepoint
							Point.x += 0.5*m_VoxSize[0];
							Point.y += 0.5*m_VoxSize[1];
							Point.z += 0.5*m_VoxSize[2];
							

							CentrePoints.push_back(Point);


						}

						++nodeindextemp;
				
				}

			}
		

		}
		RowInfo.clear();
		Textile.GetPointInformation(CentrePoints, RowInfo);
		m_ElementsInfo.insert(m_ElementsInfo.end(), RowInfo.begin(), RowInfo.end()); //size should be equal to iElementNumber at end
		CentrePoints.clear();

	}


	if (bOutputYarn && !bOutputMatrix)
	{
		m_ElementsInfo.clear();
		m_ElementsInfo = NewElementInfo;
	}

	return (iElementNumber - 1);
	
}


void CBifurcationVoxelMesh::CreateBifurcatedMaterials(ostream& Output, string Filename, CTextile& Textile, bool bMatrixOnly)
{
	//CTextileMaterials m_Materials;
	//CTextileMaterials Material = m_Materials;
	m_Materials.SetupMaterials( Textile );

	int iNumYarns=Textile.GetNumYarns();
	Output << "*****************" << endl;
	Output << "*** MATERIALS ***" << endl;
	Output << "*****************" << endl;
	map<string, pair<CObjectContainer<CMaterial>, CObjectContainer<CMaterial> > > Materials = m_Materials.GetMaterials();
	map<int, string> MaterialAssignements = m_Materials.GetMaterialAssignements();
	
	map<string, pair<CObjectContainer<CMaterial>, CObjectContainer<CMaterial> > >::iterator itMaterial;
	for (itMaterial = Materials.begin(); itMaterial != Materials.end(); ++itMaterial)
	{
		Output << "*Material, Name=" << itMaterial->first << endl;
		if ( itMaterial->second.first->GetConstants().size() == 2 )
			Output << itMaterial->second.first->GetAbaqusCommands();	
		else
			Output << itMaterial->second.first->GetAbaqusCommands( "ENGINEERING CONSTANTS" );

		if ( itMaterial->second.second->GetConstants().size() == 1 )
			Output << itMaterial->second.second->GetThermAbaqusCommands("");	
		else
			Output << itMaterial->second.second->GetThermAbaqusCommands( "ORTHO" );
	}
	int i;
	string MatName;
	for (i = -1; i < iNumYarns; ++i)
	{
		if (MaterialAssignements.count(i))
			MatName = MaterialAssignements[i];
		else
			MatName = Materials.begin()->first;
		if ( i == -1 )
		{
			Output << "*Solid Section, ElSet=Matrix, Material=" << MatName << endl;
			Output << "1.0," << endl;
		}
		else if (!bMatrixOnly)
		{
			Output << "*Solid Section, ElSet=Yarn" << i << ", Material=" << MatName << ", Orientation=TexGenOrientations" << endl;
			Output << "1.0," << endl;
		}
	}
}

//why can CPeriodicBoundaries call SetupMaterials from CTextileMaterials: because it's not a protected function